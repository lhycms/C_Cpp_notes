# 拷贝、赋值与销毁

<font color="73DB90" size="4">

内容
---
1. 拷贝构造函数 (`copy constructor`)
2. 拷贝赋值运算符 (`copy-assignment operation`)
3. 析构函数 (`destructor`)

</font>

# 1. 拷贝构造函数 (`copy constructor`)

## 1.1. 拷贝构造函数的定义
<font color="73BD90" size="4">

1. 构造函数
2. 第一个参数是`自身类型的引用`
3. 任何额外参数都有默认值

```c++
class Foo {
public:
    Foo() = default;    // 默认构造函数
    Foo(const Foo&) = default;  // 默认拷贝构造函数
}
```

<font color="red">

Note
----
1. 拷贝函数不应该是 `explicit`

</font>

</font>


## 1.2. 合成拷贝构造函数 (`synthesized copy constructor`) -- 默认的拷贝构造函数

<font color="73DB90" size="4">

1. 对于某些类来说，`合成拷贝构造函数`用来阻止我们拷贝该类类型的对象。
2. `合成拷贝构造函数`会将其`成员参数`逐个拷贝到正在创建的对象中。
3. 编译器从给定对象中依次将每个`非static成员`拷贝到正在创建的对象中。
4. 每个成员的类型决定了它图和拷贝：
    - 类类型的成员：使用其他拷贝构造函数
    - 内置类型的成员：直接拷贝
    - 数组：逐元素地拷贝

</font>

### 1.2.1. Demo 1. `Sales_data` 类的合成拷贝构造函数
```c++
class Sales_data {
public:
    // 拷贝构造函数（copy constructor）
    Sales_data(const Sales_data&);

private:
    std::string bookNo;
    int units_sold = 0;
    double reveune = 0.0;
}

// 与 Sales_data 的合成的拷贝构造函数等价
Sales_data::Sales_data(const Sales_data &orig) :
    bookNo(orig.bookNo),
    units_sold(orig.units_sold),
    revenue(orig.revenue)
    { } // 空函数体
```


## 1.3. 拷贝初始化
<font color="73DB90" size="4">

1. 现在我们可以理解`直接初始化`和`拷贝初始化`的区别：
   1. `直接初始化`：调用 `构造函数(constructor)`
   2. `拷贝初始化`：我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行`类型转换`。
```c++
/*
    有 `=` 的都是 `拷贝初始化`
*/
std::string dots(10, ',');  // 直接初始化
std::string s(dots);        // 直接初始化
std::string s2 = dots;      // 拷贝初始化
std::string null_book = "9-999";    // 拷贝初始化
std::string nines = std::string(100, '9');  // 拷贝初始化
```

</font>

## 1.3.1. 调用`拷贝构造函数`的情形
<font color="73DB90" size="4">

1. 使用 `=` 进行赋值
2. 将一个对象作为`实参`传递给一个`非引用类型的形参`
3. 从一个`返回类型为非引用类型`的函数返回一个对象
4. 用`花括号`初始化一个`数组中`的元素或一个`聚合类`中的成员

</font>


# 2. 拷贝赋值运算符 (`copy-assignment operator`)

<font color="73DB90" size="4">

1. 与类控制其对象`如何初始化`一样，类也可以控制其对象`如何赋值`:
```c++
Sales_data trans, accum;
trans = accum;  // 使用 Sales_data 的拷贝赋值运算符
```
2. 与`拷贝构造函数`一样，如果类未定义自己的`拷贝赋值运算符`，编译器会为它合成一个

</font>

## 2.1. 重载赋值运算符

### 2.1.1. 运算符重载
<font color="73DB90" size="4">

1. 运算符重载的本质是`函数`，其名字由`operator`关键字后接要定义的运算符的符号组成。
    - 赋值运算符名为 `operator=`
2. 如果一个运算符是一个`成员函数`，其`左侧运算的对象`就绑定到隐式的`this`参数。
    - 对于一个二元运算符，例如赋值运算符，其右侧对象作为显式参数传递。

</font>

### 2.1.2. 拷贝赋值运算符使用
```c++
class Foo {
public: 
    // 赋值运算符通常应该返回一个 `指向其左侧运算对象的引用`
    Foo& operator=(const Foo&); // 赋值运算符
}
```


### 2.1.3. 合成拷贝赋值运算符
<font color="73DB90" size="4">

1. 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个`合成拷贝赋值运算符 (synthesized copy-assignment operator)`
2. 类似`拷贝构造函数`：
   1. 对于某些类来说，`合成拷贝赋值运算符`用来阻止我们拷贝该类类型的对象。
   2. `合成拷贝赋值运算符`会将其`成员参数`逐个拷贝到正在创建的对象中。
   3. 编译器从给定对象中依次将每个`非static成员`拷贝到正在创建的对象中。

```c++
Sales_data& Sales_data::operator=(const Sales_data &rhs){
    bookNo = rhs.bookNo;
    units_sold = rhs.units_sold;
    revenue = rhs.revenue;
    return *this;   // 返回一个此对象的引用
}
```

</font>










# 练习
## 13.5
```c++
#include <iostream>


class HasPtr {

public:
    // Constructor Function
    HasPtr( const std::string &s = std::string() ) :
        ps( new std::string(s) ),
        i(0) 
        {   }
    
    // Copy Constructor Function
    HasPtr( const HasPtr &has_ptr ) :
        *ps( *has_ptr.ps ),
        i(has_ptr.i)
        {   }

private:
    // Data member 
    std::string *ps;
    int i;

}
```


## 13.8.
```c++
#include <iostream>


class HasPtr {

public:
    // Constructor Function
    HasPtr( const std::string &s = std::string() ) :
        ps( new std::string(s) ),
        i(0) 
        {   }
    
    // Copy-assignment operator
    HasPtr& operator=(const HasPtr &rhs) {
        *ps = *rhs.ps;
        i = rhs.i;
    }

private:
    // Data member 
    std::string *ps;
    int i;

}
```