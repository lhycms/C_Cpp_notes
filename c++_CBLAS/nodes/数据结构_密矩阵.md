# 1. 密矩阵(dense matrix)
密矩阵(dense matrix)：一般来说，矩阵的每个元在计算机中逐个储存，这种数据结构就叫做密矩阵


# 2. 行主序(row-major)、列主序(column-major)

## 2.1. 定义
在计算机内存中所有数据都是按照顺序排成一排，所以存储矩阵有以下两种选择：
1. 行主序(row-major): 把矩阵的行首尾相接
2. 列主序(column-major): 把矩阵的列首尾相接

## 2.2. 举例说明
例如对于 `2 * 2` 的矩阵 $A$:
1. 行主序(row-major): $A_{11}, A_{12}, A_{21}, A_{22}$
2. 列主序(column-major): $A_{11}, A_{21}, A_{12}, A_{22}$

## 2.3. 使用
- 在 fortran 和 Matlab 中，语言自带的矩阵都是`列主序`
- C/C++ 中如果用指针的指针（或数组的数组）来表示矩阵，得到的将会是`行主序`．当然，由于 C++ 的灵活性，我们完全可以创造行主序和列主序两种不同的矩阵类．由于 C++ 的数组的指标从 0 开始，那么矩阵的行标和列表也习惯从 0 开始．


在我们用双索引寻找矩阵元时，我们需要先将其转换为单索引。（从性能角度来看，单索引要比多个索引要快．）设矩阵尺寸为 $N_1 * N_2$，那么
$$n = i + N_1j{\quad}(列主序)\\
  n = N_2i + j{\quad}(行主序)\\
  (i=0, 1, ..., N_1-1;{\quad}j=0, 1, ..., N_2-1)$$

行主序和列主序也可以延申至高维矩阵，如果使用列主序，那么当我们在内存中按顺序读取数据的时候，第 1 个索引（index）将变化得最快，第 2 个索引变化得第二快，最后得索引变化得最慢．行主序则相反，最后的索引变化得最快，而第一个最慢．例如 4 维数组的多索引变为单索引的公式为
$$n = i_1 + N_1i_2 + N_1N_2i_3 + N_1N_2N_3i_4{\quad} \\
  n = N_2N_3N_4i_1 + N_3N_4i_2 + N_4i_3 + i_4{\quad}$$


若要由单索引计算多索引，我们可以用整数除法（向下取整）/ 和求余运算 %，例如对列主序的矩阵有
$$i = n \% N\\
  j = n / N$$