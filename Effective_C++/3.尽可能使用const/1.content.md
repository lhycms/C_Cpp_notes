# 尽可能使用 const (`Use const whenever possible`)
1. `const` 指定一个`不该被改动`的对象，编译器会强制实施这项约束


# 1. 指针(pointer) 与 `const`
1. 你可以指出指针自身、指针所指物、或两者都是`const`:
   1. `const` 出现在 `*` 左边：被指物是`常量`
   2. `const` 出现在 `*` 右边：指针本身是`常量`
```c++
char greeting[] = "Hello";

char *p = greeting;     // non-const pointer, non-const data
const char* p = greeting; // non-const pointer, const data
char* const p = greeting; // const pointer, non-const data
const char* const p = greeting; // const pointer, const data
```

2. 当被指物是常量时（`const` 在 `*` 左边），以下两种情况是等效的:
   1. `const` 在类型之前
   2. `const` 在类型之后
```c++
void f1(const Widget* pw);
void f2(Widget const* pw);
```


# 2. 迭代器(iterator) 与 `const`
1. `STL 迭代器`是以指针为根据塑膜出来的，所以迭代器的作用就像个 `T*` 指针。
2. 声明迭代器为 `const` 就像声明指针为 `const` 一样（即声明一个 `T* const` 指针）
3. `const_iterator` 类型的迭代器：迭代器所指向的东西不可被改动。
```c++
std::vector<int> vec;

/*
    Part I.
*/
const std::vector<int>::iterator iter = vec.begin();    // iter 的作用像个 `T* const`
*iter = 10; // 正确，改变 iter 的所指物
++iter;     // 错误，iter 是 const


/*
    Part II.
*/
std::vector<int>::const_iterator iter = vec.begin();    // iter 的作用像个 `const T*`
*iter = 10; // 错误，*iter 是const
++iter;     // 正确，改变 iter
```

# 3. 令函数返回一个`常量值`
1. <font color="red" size="4">令`函数返回一个常量值 (const)`，往往可以降低因程序员错误而造成的意外。</font>

## 3.1. Demo 1: 有理数 (Rational numbers) 的 `operator*` 声明式
```c++
class Rational {...};

// 注意：此处返回的 Rational object（return by value），而不是 reference。意味着返回的是一个`副本`
const Rational operator*(const Rational& lhs, const Rational& rhs);
```

1. 如果上述返回的不是 `const` 对象，则有可能出现如下的暴行：
```c++
Rational a, b, c;
(a * b) = c;    // 在 a*b 的成果上调用 operator=

if (a * b = c) ...  // 此处我们仅仅想做一个比较，但由于输入错误，变成了赋值 (`==` -> `=`)
// 如果 operator* 返回的是 const，就可以及时发现这个错误
```


# 4. `const` 成员函数
