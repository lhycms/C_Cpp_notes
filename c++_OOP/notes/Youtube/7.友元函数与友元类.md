<font color="73DB90" size="4">

`友元函数/友元类`的作用
--------------------
1. 有时需要定义一些函数，这些函数不是类的一部分，但又需要频繁访问类的`私有（private）`成员和`保护（protected）`成员，这时可以将这些函数定义为友元函数。
2. 友元函数：
    - 类体内声明 (`Declaration Inside Class Body`)：`friend void PrintReSult(Circle &circle);`
    - 类体外声明 (`Definition Outside Class Body`)：`void PrintResult(Circle &circle) {...}`
3. 友元类：
    - 类体内声明 (`Declaration Inside Class Body`)：`friend class Homework;`
    - 类体外声明 (`Definition Outside Class Body`)：`class Homework {...}`

</font>

# Friend functions and Friend classes in C++
<font color="orange" size="4">

1. 某个类的 友元函数 / 友元类 可以访问该类的 `protected` / `private` member.
2. All members of a class is `private`.
3. All members of a structure is `public`.

</font>

# 1. Friend function (友元函数) Demo
<font color="orange" size="4">

1. 类可以有很多友元函数。
2. 谨慎选择类的友元函数。
3. Friendship is not mutual. (友元关系不是可逆的)
4. Friendship is not inherited. (友元关系不可继承，即 `DerivedClass` 不可以继承 `BaseClass` 的 Friendship 友元关系)

</font>

```c++
#include <iostream>

class EquilateralTriangle {
private:
    float a;
    float circumference;
    float area;

public:
    void setA(float length) {
        this->a = length;
        this->circumference = a * 3;
        this->area = (1.73 * a * a) / 4; 
    }

    // Friend function of class `EquilateralTriangle` -- Declaration
    friend void PrintResults(EquilateralTriangle& et);
};


// Friend function of `EquilateralTriangle` -- Definition 
void PrintResults(EquilateralTriangle& et) {
    std::cout << "Circumference: " << et.circumference << std::endl;
    std::cout << "Area: " << et.area << std::endl;  
}


int main() {
    EquilateralTriangle et;
    et.setA(3);

    PrintResults(et);

    return EXIT_SUCCESS;
}
```

# 2. Friend class (友元类) Demo

```c++
#include <iostream>


class EquilateralTriangle {
private:
    float a;
    float circumference;
    float area;

public:
    void setA(float length) {
        this->a = length;
        this->circumference = a * 3;
        this->area = (1.73 * a * a) / 4; 
    }

    // Friend class of class `EquilateralTriangle` -- Declaration
    friend class Homework;
};


// Friend class of `EquilateralTriangle` -- Definition 
class Homework {
public: 
    void PrintResults(EquilateralTriangle& et) {
        std::cout << "Circumference: " << et.circumference << std::endl;
        std::cout << "Area: " << et.area << std::endl;  
    }
};



int main() {
    EquilateralTriangle et;
    et.setA(3);
    
    Homework h;
    h.PrintResults(et);

    return EXIT_SUCCESS;
}
```


# 3. 利用 `class` 和 `friend` 实现运算符重载的 Demo

<font color="orange" size="4">

1. All members of a class is `private`.
2. All members of a structure is `public`.

</font>

```c++
#include <iostream>
#include <string>
#include <list>


class YouTubeChannel {
private:
    std::string Name;
    unsigned int SubscribersCount;

public:
    friend std::ostream& operator<<(std::ostream& COUT, YouTubeChannel& ytChannel);

    // Constructor Function
    YouTubeChannel(std::string name, unsigned int subscribersCount) {
        this->Name = name;
        this->SubscribersCount = subscribersCount;
    }

    // operator `==` overloading
    bool operator==(const YouTubeChannel& ytChannel) const {
        return this->Name == ytChannel.Name;
    } 
};

// Friend function for class `YouTubeChannel` (Global) 
std::ostream& operator<<(std::ostream& COUT, YouTubeChannel& ytChannel) {
    COUT << "Name: " << ytChannel.Name << std::endl;
    COUT << "SubscribersCount: " << ytChannel.SubscribersCount << std::endl;
    return COUT;
}


class MyCollection {
private:
    std::list<YouTubeChannel> myChannels;

public:
    friend std::ostream& operator<<(std::ostream& COUT, MyCollection& myCollection);

    void operator+=(YouTubeChannel ytChannel) {
        this->myChannels.push_back(ytChannel);
    }

    void operator-=(YouTubeChannel ytChannel) {
        this->myChannels.remove(ytChannel);
    }
};

// Friend function for class `MyCollection` (Global) 
std::ostream& operator<<(std::ostream& COUT, MyCollection& myCollection) {
        for (YouTubeChannel ytChannel: myCollection.myChannels)
            std::cout << ytChannel << std::endl;
        return COUT;
}


int main() {
    YouTubeChannel yt1 = YouTubeChannel("CodeBeauty", 75000);
    YouTubeChannel yt2 = YouTubeChannel("The second channel", 80000);

    MyCollection myCollection;
    myCollection += yt1;
    myCollection += yt2;
    myCollection -= yt1;

    std::cout << myCollection;

    return EXIT_SUCCESS;
}
```