<font color="red" size="4">

开始创建空的 vector 对象，在运行时再动态添加元素，这一做法与 C 语言不同。尤其用惯了 C 语言或 Java。（即创建 vector 时，不用指定 vector 的容量） 

</font>


# 1. 定义和初始化 `vector` 对象
<font color="orange" size="4">

初始化 vector 对象的方法
---------------------
1. `vector<T> v1`: v1 是一个空 vector，它潜在的元素是 T 类型的，执行默认初始化
2. `vector<T> v2(v1)`: v2 中包含 v1 所有元素的副本
3. `vector<T> v2 = v1`: 等价于 `v2(v1)`，v2中包含 v1 中所有的元素
4. `vector<T> v3(n, val)`: v3 包含n个重复的元素，每个元素的值都是 val
5. `vector<T> v4(n)`: 指定元素个数为 n
6. `vector<T> v5{a, b, c...}`: 包含初始值个数的元素，每个元素被赋予相应的初始值
7. `vector<T> v5 = {a, b, c...}`: 等价于 `vector<T> v5{a, b, c...}`

列表初始值还是元素数量？
------------------
1. 圆括号：提供的值是用来构造 (construct)，vector的
2. 花括号：花括号内的值是元素初始值的列表
</font>

# 2. `vector`对象的其他操作
<font color="orange" size="4">

1. `vector.push_back(t)`: 在 vector 末尾添加一个元素
2. `vector.begin()`: 返回一个迭代器，指向第一个元素
3. `vector.end()`: 返回一个迭代器，指向最后一个元素后面的那个元素
4. `vector.empty()`: 
5. `vector.size()`: 返回 v 中元素的个数。返回的类型是 `vector<Y>::size_type`
6. `vector[n]`: 返回 v 中第 n 个位置上元素的引用
7. `v1 = v2`:
8. `v1 == v2`:
9. `v1 != v2`:
10. `<, <=, >, >=`:
11. `v.erase(iterator_start, iterator_end)`: 本函数使迭代器失效，返回一个新的迭代器(iterator)
12. `v.pop_back()`: 删除尾部元素

</font>


<font color="red" size="4">

Note
----
1. 不能使用下标形式添加元素，最好使用 `vector.push_back(t)` 在 vector 对象末尾添加元素 -- `缓冲区溢出（buffer overflow）`
2. 试图用下标形式访问一个不存在的元素，将引发错误，不过这种错误不会被编译器发现，而是在运行时出现一个未可知的值
3. 防止缓冲区溢出的最好办法：使用 `for` 范围循环

</font>